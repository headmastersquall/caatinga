#!/usr/bin/env python

# Copyright 2014 Chris Taylor
#
# This file is part of caatinga.
#
# Caatinga is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Caatinga is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with caatinga.  If not, see <http://www.gnu.org/licenses/>.

import os
import errno
import caatinga.core.functions as fn
import caatinga.caat.backup as backup
from time import strftime
from caatinga.caat.organizer import organize
from caatinga.core.args import getArgs
from caatinga.core.validation import SettingsValidator

__version__ = "caatinga version: 1.0.3"


class CleanExitException(Exception):
    pass


def main():
    """
    Application entry point.
    """
    try:
        run_backup()
        exit(0)
    except OSError as er:
        if er.errno == errno.ENOSPC:
            print("Backup drive is full")
        elif er.errno == errno.EACCES:
            print("Permission Denied")
        else:
            print("Operation not permitted on the mounted backup file system")
        exit(er.errno)
    except KeyboardInterrupt:
        exit(1)
    except Exception as ex:
        print(str(ex).strip("'"))
        exit(1)


def run_backup():
    """
    Main method that performs the backup.
    """
    commandArgs = getArgs()
    if commandArgs.version:
        print(__version__)
        exit(0)

    settings = fn.getSettingsInstance(commandArgs)
    SettingsValidator().validate(settings)
    backupHome = fn.getBackupHome(settings.backupLocation, settings.hostName)
    lockFile = getLockFile(backupHome)
    outputWriter = fn.getOutputWriter(commandArgs.verbose)
    previousBackup = os.path.realpath(fn.getLatestLink(backupHome))

    lock(lockFile)
    fn.runHooks(settings.preBackupHooksDir)
    runNonBackupFunctions(settings, commandArgs, backupHome, outputWriter)
    executeBackup(previousBackup, settings, outputWriter, backupHome, lockFile)
    runPostBackupFunctions(settings, backupHome, outputWriter)
    fn.runHooks(settings.postBackupHooksDir)


def runNonBackupFunctions(settings, commandArgs, backupHome, outputWriter):
    try:
        checkForRegisterOption(settings, commandArgs)
        checkForDeleteOldest(commandArgs, backupHome)
        markPartialBackupForDeletion(backupHome)
        checkForClean(commandArgs, backupHome, outputWriter)
    except CleanExitException:
        fn.runHooks(settings.postBackupHooksDir)
        exit(0)


def executeBackup(previousBackup, settings, outWriter, backupHome, lockFile):
    try:
        backupRoot = backup.createBackupRoot(
            backupHome,
            strftime("%Y-%m-%d-%H%M%S") + ".part",
            settings.backupgid)

        backup.backupDirectory(
            backupRoot,
            previousBackup,
            settings.root,
            settings,
            outWriter)
        os.rename(backupRoot, backupRoot.replace(".part", ""))
        fn.updateLatestLink(backupHome)
    finally:
        backup.removeLockFile(lockFile)


def runPostBackupFunctions(settings, backupHome, outputWriter):
    checkForReduceBackups(settings.reduceBackups, backupHome)
    checkMaxImages(settings.maxImages, backupHome)
    deleteBackupsMarkedForDeletion(backupHome, outputWriter)
    checkDrivePercentage(backupHome, settings.drivePercentage, outputWriter)


def checkForRegisterOption(settings, commandArgs):
    """
    Check the command args for the register option and register the backup
    device if provided.  This will exit with a status 0 if a device was
    registered.
    """
    if commandArgs.register:
        fn.registerBackupDevice(
            settings.backupLocation,
            settings.backupgid)
        print(("The device mounted at {0} is now registered as a " +
              "backup device.").format(settings.backupLocation))
        raise CleanExitException()


def getLockFile(backupHome):
    """
    Returns the name of the lock file based on the executable name.
    """
    return os.path.join(backupHome, __file__ + ".pid")


def checkForDeleteOldest(commandArgs, backupHome):
    """
    Check if the option to delete the oldest backup was provided, and delete
    the oldest backup.
    """
    if commandArgs.deleteOldest:
        fn.deleteBackup(backupHome, fn.getOldestBackup(backupHome))
        raise CleanExitException()


def markPartialBackupForDeletion(backupHome):
    """
    Looks for any partial backups and marks them for deletion.
    """
    if not os.path.exists(backupHome):
        return
    partials = fn.getPartialBackups(backupHome)
    for partial in partials:
        partialBackup = os.path.join(backupHome, partial)
        os.rename(partialBackup, partialBackup.replace(".part", ".delete"))


def checkForClean(commandArgs, backupHome, writer):
    """
    If the clean option is given, delete any backups marked for deletion,
    then exit.
    """
    if commandArgs.clean:
        deleteBackupsMarkedForDeletion(backupHome, writer)
        raise CleanExitException()


def _isPidRunning(pid):
    try:
        os.kill(pid, 0)
        return True
    except OSError as e:
        return e.errno == errno.EPERM


def lock(lockFile):
    """
    Creates a lock file if one is not present.  If a lock file already exists,
    an exception will be thrown.
    """
    if os.path.exists(lockFile):
        with open(lockFile) as lock:
            pid = int(lock.readline())
        if _isPidRunning(pid):
            raise Exception("A backup is currently running [{}]".format(pid))
        else:
            os.remove(lockFile)
    backup.createLockFile(lockFile)


def checkForReduceBackups(reduceBackups, backupHome):
    """
    Reduce the backups if the reduce backups option is provided.
    """
    if reduceBackups:
        organize(backupHome)


def checkMaxImages(maxImages, backupHome):
    """
    When the number of backup images are greater than the max provided in
    settings, mark the extra images to be deleted.
    """
    if maxImages:
        backups = fn.getBackups(backupHome)
        toRemove = list(backups.keys())[:len(backups.keys()) - maxImages]
        for backup in toRemove:
            fn.markBackupForDeletion(backupHome, backups[backup])


def deleteBackupsMarkedForDeletion(backupHome, writer):
    """
    Delete backups that are marked to be deleted.
    """
    for backup in fn.getBackupsMarkedForDeletion(backupHome):
        writer("Deleting: {0}".format(backup))
        fn.deleteBackup(backupHome, backup)


def checkDrivePercentage(backupHome, drivePercentage, writer):
    '''
    Compares drive usage with user settings and deletes old backups as
    necessary.
    '''
    while drivePercentage < fn.getDriveUsagePercentage(backupHome):
        if len(fn.getBackups(backupHome)) <= 1:
            break
        oldest = fn.getOldestBackup(backupHome)
        writer("Deleting: {0}".format(oldest))
        fn.deleteBackup(backupHome, oldest)

if __name__ == "__main__":
    main()
